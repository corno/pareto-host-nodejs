"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create_asynchronous_processes_monitor = create_asynchronous_processes_monitor;
const panic_1 = require("./panic");
/**
 * this function helps in keeping track of ongoing async operations
 * async operations are registered and when finished reported as such.
 * when all ongoing operations are finished the onEnd callback is called
 *
 * this function is specifically useful for async map functions
 *
 * @param callback this callback creates a scope within which the counter is provided
 * @param onEnd this callback will be called when all ongoing operations are finished
 */
function create_asynchronous_processes_monitor(monitoring_phase, on_all_finished) {
    let counter = 0;
    /*
     * we need to keep track of if the registration phase is ended or not.
     * it can happen that the counter reaches 0 during the registration phase, specifically if there is no real async calls being made
     * in that case the reportFinished counter is als called during the registration phase.
     * If that happens there should not yet be a call to onEnd().
     */
    let registration_phase_ended = false;
    let on_all_finished_has_been_called = false;
    function checkStatus() {
        if (registration_phase_ended) {
            if (counter === 0) {
                if (on_all_finished_has_been_called === true) {
                    (0, panic_1.panic)("CORE: already ended");
                }
                on_all_finished_has_been_called = true;
                on_all_finished();
            }
        }
    }
    monitoring_phase({
        'report process started': () => {
            if (on_all_finished_has_been_called) {
                (0, panic_1.panic)("CORE: async call done after context is ready");
            }
            counter += 1;
        },
        'report process finished': () => {
            if (counter === 0) {
                (0, panic_1.panic)("CORE: decrement while counter is 0");
            }
            counter -= 1;
            checkStatus();
        },
    });
    registration_phase_ended = true;
    checkStatus();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlX2FzeW5jaHJvbm91c19wcm9jZXNzZXNfbW9uaXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jcmVhdGVfYXN5bmNocm9ub3VzX3Byb2Nlc3Nlc19tb25pdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBaUJBLHNGQThDQztBQS9ERCxtQ0FBK0I7QUFPL0I7Ozs7Ozs7OztHQVNHO0FBQ0gsU0FBZ0IscUNBQXFDLENBQ2pELGdCQUE4QyxFQUM5QyxlQUEyQjtJQUczQixJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUE7SUFFZjs7Ozs7T0FLRztJQUNILElBQUksd0JBQXdCLEdBQUcsS0FBSyxDQUFBO0lBQ3BDLElBQUksK0JBQStCLEdBQUcsS0FBSyxDQUFBO0lBRTNDLFNBQVMsV0FBVztRQUNoQixJQUFJLHdCQUF3QixFQUFFLENBQUM7WUFFM0IsSUFBSSxPQUFPLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQ2hCLElBQUksK0JBQStCLEtBQUssSUFBSSxFQUFFLENBQUM7b0JBQzNDLElBQUEsYUFBSyxFQUFDLHFCQUFxQixDQUFDLENBQUE7Z0JBQ2hDLENBQUM7Z0JBQ0QsK0JBQStCLEdBQUcsSUFBSSxDQUFBO2dCQUN0QyxlQUFlLEVBQUUsQ0FBQTtZQUNyQixDQUFDO1FBQ0wsQ0FBQztJQUNMLENBQUM7SUFDRCxnQkFBZ0IsQ0FBQztRQUNiLHdCQUF3QixFQUFFLEdBQUcsRUFBRTtZQUMzQixJQUFJLCtCQUErQixFQUFFLENBQUM7Z0JBQ2xDLElBQUEsYUFBSyxFQUFDLDhDQUE4QyxDQUFDLENBQUE7WUFDekQsQ0FBQztZQUNELE9BQU8sSUFBSSxDQUFDLENBQUE7UUFFaEIsQ0FBQztRQUNELHlCQUF5QixFQUFFLEdBQUcsRUFBRTtZQUM1QixJQUFJLE9BQU8sS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDaEIsSUFBQSxhQUFLLEVBQUMsb0NBQW9DLENBQUMsQ0FBQTtZQUMvQyxDQUFDO1lBQ0QsT0FBTyxJQUFJLENBQUMsQ0FBQTtZQUNaLFdBQVcsRUFBRSxDQUFBO1FBQ2pCLENBQUM7S0FDSixDQUFDLENBQUE7SUFDRix3QkFBd0IsR0FBRyxJQUFJLENBQUE7SUFDL0IsV0FBVyxFQUFFLENBQUE7QUFDakIsQ0FBQyJ9